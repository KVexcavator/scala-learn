Параметризованные типы против членов абстрактного типа

Scala поддерживает параметризованные типы, где квадратные скобки ([…]) заключают параметр типа, например Seq[T]. Поскольку мы можем подключить практически любой тип для параметра типа T, эта функция называется параметрическим полиморфизмом. Универсальные реализации методов List могут использоваться с экземплярами любого типа T (параметра), вызывая полиморфное поведение (для всех List[T]).
Рассмотрим объявление Map, которое записано следующим образом, где K — тип ключей, а V — тип значений.

trait Map[K, +V] extends Iterable[(K, V)] with ...

Знак + перед V означает, что Map[K, V2] является подтипом Map[K, V1] для любого V2, который является подтипом V1. Это называется ковариантной типизацией.Если у нас есть функция f(map: Map[String, Any]), то имеет смысл, что передача ей Map[String, Double] должна работать нормально, потому что функция должна принимать значения Any, супертипа Double.
Напротив, ключ K инвариантен. Мы не можем передать Map[Any, Any] в f, или любой Map[S, Any] для некоторого подтипа или супертипа S String.

Если перед параметром типа стоит тире (–), то связь меняется на противоположную: Foo[B] будет супертипом Foo[A], если B является подтипом A, а объявление — Foo[-A] (так называемая контравариантная типизация).

Scala поддерживает другой тип механизма абстракции, называемый абстрактными членами типа, который может применяться ко многим из тех же проблем проектирования, для которых используются параметризованные типы.
Члены абстрактного типа объявляются как члены других типов, как и абстрактные методы и поля. Вот пример, который использует член абстрактного типа в супертипе, а затем делает тип конкретным в подтипах, где он становится псевдонимом для других типов:

// src/main/scala/progscala3/typelessdomore/BulkReaderAbstractTypes.scala
package progscala3.typelessdomore
import scala.io.Source

abstract class BulkReader:
  type In 
  /** The source of data to read. */
  val source: In
  /** Read source and return a sequence of Strings */
  def read: Seq[String]

case class StringBulkReader(source: String) extends BulkReader:
  type In = String
  def read: Seq[String] = Seq(source)

case class FileBulkReader(source: Source) extends BulkReader:
  type In = Source
  def read: Seq[String] = source.getLines.toVector

1) Член абстрактного типа, аналогичный абстрактному полю или методу.
2) Конкретный подтип BulkReader, где In определен как псевдоним для String, тип исходного параметра, переданного в StringBulkReader, должен совпадать.
3) Конкретный подтип BulkReader, где In определен как псевдоним для Source, типа библиотеки Scala для чтения источников, таких как файлы. Source.getLines возвращает итератор, который мы можем прочитать в Vector с помощью toVector.

