===========================================
Метод с параметрами по умолчанию и именованными параметрами.

case class Point(x: Double = 0.0, y: Double = 0.0): 
  def shift(deltax: Double = 0.0, deltay: Double = 0.0) = 
    copy(x + deltax, y + deltay)
Определяется Point со значениями инициализации по умолчанию. Для классов case и x, и y автоматически являются неизменяемыми (val) полями.
Новый метод «shift» для создания нового экземпляра Point, смещенного относительно существующего Point.
Метод «copy» также создается автоматически для классов case. Он позволяет вам создавать новые экземпляры класса case, указывая только те поля, которые изменяются. Это очень удобно для классов case с большим количеством полей:
val p1 = Point(x = 3.3, y = 4.4)
val p2 = p1.copy(y = 6.6)
=============================================
Методы с несколькими списками параметров

abstract class Shape():
  def draw(offset: Point = Point(0.0, 0.0))(f: String => Unit): Unit =
    f(s"draw: offset = $offset, shape = ${this}")
У draw есть два списка параметров, каждый из которых имеет один параметр, а не один список параметров с двумя параметрами. Первый список параметров позволяет указать точку смещения, в которой будет нарисована фигура. Он имеет значение по умолчанию Point(0.0, 0.0), что означает отсутствие смещения.
как применить:
al s = Circle(Point(0.0, 0.0), 1.0)
s.draw(Point(1.0, 2.0))(str => println(str))
или 
s.draw(Point(1.0, 2.0))(println)
тоже будет работать (не рекомендуется
s.draw(Point(1.0, 2.0), str => println(str)))
рекомендуется с витыми скобками*
s.draw(Point(1.0, 2.0)){str => println(str)}
* похоже на передачу блока в аргументы

==================================================
Определения методов вложения и рекурсия

def factorial(i: Int): BigInt =
  def fact(i: Int, accumulator: BigInt): BigInt =
    if i <= 1 then accumulator
    else fact(i - 1, i * accumulator)

  fact(i, BigInt(1))

(0 to 5).foreach(i => println(s"$i: ${factorial(i)}"))
===================================================
Вывод информации о типе
48
